import os
import sys

from SCons.Action import CommandAction 
from SCons.Errors import StopError 

PathJoin = os.path.join
PathBaseName = os.path.basename
PathExists = os.path.exists

def Macroses(self, *macroses):
    prefix = '-D'
    
    if self['CC'] == 'cl':
        prefix = '/D'
        
    for macro in macroses:
        self.Append(CCFLAGS = prefix + macro)
    
def SupportedPlatform(self, platform):
    return platform in self['PLATCHAIN']

def BuildDir(self, dir):
    return PathJoin('#build', 'build', dir)

def Target(self, tgtdir, target = ''):
    if sys.platform == 'win32':
        if tgtdir in ('bin', 'lib', 'etc'):
            tgtdir = ''
    
    target = PathJoin(tgtdir, target)    
    self['CURTARGET'] = target
    
    return PathJoin('#build', self['PLATFORM'], target)

def AddDeps(self, *deps):
    for dir, dep in deps:
        inc_dir = PathJoin(dep, 'include')
        
        self['CPPPATH'] += [self.BuildDir(inc_dir)]
        self['LIBS'] += [dep]

def Module(self, mod_name):
    mod = self.Clone(CFLAGS = ['-DNO_JSON'])
    
    mod.AddDeps(('lib', 'libtscommon'), ('lib', 'libtsload'))
    mod.SharedLibrary(mod.Target('mod', mod_name), Glob("src/*.c"))

def InstallFile(self, target, file):
    self.Command(self.Target(target, str(file)),
                 file, Copy("$TARGET", "$SOURCE"))

def PreparePlatform(self):
    self.Append(ENV = {'PLATCACHE': PathJoin(Dir('.').path, self['PLATCACHE'])})
    self.Append(ENV = {'PLATDEBUG': self['PLATDEBUG']})
    
    plat_chain = self['PLATCHAIN']
    rev_plat_chain = list(reversed(plat_chain))
    
    plat_cache = self['PLATCACHE']
    plat_includes = []
    
    self.PlatIncBuilder(plat_cache, Dir('include').glob('*.h'))
    
    # Build platform-chained includes and sources
    
    for plat_name in plat_chain:      
        # For each platform-dependent include select best match and copy
        # it from plat/<platform>/include.h to plat/include.h
        for inc_file in Dir('include').Dir('plat').Dir(plat_name).glob('*.h'): 
            base_name = PathBaseName(str(inc_file))
            dest_file = PathJoin('include/plat', base_name)
            
            if base_name not in plat_includes:
                self.Command(dest_file, inc_file, Copy("$TARGET", "$SOURCE"))
                
                plat_includes.append(base_name)
    
    for plat_name in rev_plat_chain:
        # Parse source files for platform-api function implementation
        # and select best match for it
        for src_file in Dir('src').Dir('plat').Dir(plat_name).glob('*.c'):            
            tgt_file = File(str(src_file).replace(PathJoin('src', 'plat'), 'plat'))            
            
            # Each source file depends on platform cache
            # and all source that are more specific than this file
            # Otherwise SCons will select generic implementation
            base_name = PathBaseName(str(src_file))
            
            # We need it for dependent platforms, because VariantDir was not processed yet
            src_path = Dir('src').srcnode().abspath
            
            self.Depends(tgt_file, plat_cache)
            
            # Add dependencies for all available platforms to ensure that
            # most specific platform will be built earlier than "generic" platform
            for dep_plat_name in rev_plat_chain[rev_plat_chain.index(plat_name) + 1:]:
                dep_plat_path = PathJoin('plat', dep_plat_name, base_name)
                
                # Cannot use SCons.Node here because it creates dependencies for non-existent files
                dep_file = PathJoin(src_path, dep_plat_path)
                if not PathExists(dep_file):
                    continue
                
                self.Depends(tgt_file, File(dep_plat_path))
            
            # Add builder 
            self.PlatSrcBuilder(tgt_file, src_file)

def CompileSharedLibrary(self, extra_sources = []):
    objects = self.SharedObject(Glob("src/*.c") + Glob("plat/*/*.c") + extra_sources)
    
    # In Solaris we need to convert types from DWARF into CTF
    if self.SupportedPlatform('solaris') and self['CTFCONVERT']:
        self.AddPostAction(objects, CommandAction('$CTFCONVERT -l $TSVERSION $TARGET'))
    
    return objects
    
def CompileProgram(self, extra_sources = []):
    objects = self.Object(Glob("src/*.c") + Glob("plat/*/*.c") + extra_sources)
    return objects

def LinkSharedLibrary(self, target, objects):
    library = self.SharedLibrary(self.Target('lib', target), objects)
    
    if self.SupportedPlatform('solaris') and self['CTFMERGE']:
        self.AddPostAction(library, '$CTFMERGE -l $TSVERSION -o $TARGET $SOURCES')
    
    return library

# Prepare build environment

env = DefaultEnvironment(ENV = {'PATH': os.environ['PATH']})

env.AddMethod(AddDeps)
env.AddMethod(Macroses)
env.AddMethod(BuildDir)
env.AddMethod(Target)
env.AddMethod(Module)
env.AddMethod(InstallFile)
env.AddMethod(PreparePlatform)
env.AddMethod(SupportedPlatform)
env.AddMethod(CompileSharedLibrary)
env.AddMethod(CompileProgram)
env.AddMethod(LinkSharedLibrary)

env['TSPROJECT'] = 'vPerfGenerator agent'
env['TSVERSION'] = '0.2'

env['DEPTARGETS'] = {}
env['CURTARGET'] = ''

env['CPPPATH'] = ['#include', 'include']
env['LIBPATH'] = []
env['LIBS'] = []

env['CCFLAGS'] = []

if env['CC'] == 'gcc': 
    env['CCFLAGS'] += ['-Wall']

if env['CC'] == 'gcc':
    # env[] syntax not working here :( 
    env.Append(LINKFLAGS = ['-zorigin'])
    env.Append(RPATH = env.Literal(os.path.join('\\$$ORIGIN', os.pardir, 'lib')))

# For debugging
if env['CC'] == 'gcc':
    env['CCFLAGS'] += ["-g"]
elif env['CC'] == 'cl':
    env['CCFLAGS'] += ["/Zi"]
    env['LINKFLAGS'] += ["/debug"]

# For VS2010 Express we have to pass some env variables:
if env['CC'] == 'cl':
    env.Append(ENV = {'LIB' : os.environ.get('LIB')})
    env.Append(ENV = {'INCLUDE' : os.environ.get('INCLUDE')})

env.Macroses("TS_LOCK_DEBUG")

env.Macroses('JSON_DEBUG', 'JSON_MEMORY_CALLBACKS', 'JSON_INT_TYPE=long long')

if env['CC'] == 'gcc':
    # Supress "unused" warnings
    env['CCFLAGS'] += ['-Wno-unused-label', '-Wno-unused-variable', '-Wno-unused-function']

# Cross-platform build
PLATFORM_CHAIN = {'win32': ['win', 'generic'],
                  'posix': ['linux', 'posix', 'generic'],       # Strangely SCons detects linux as posix
                  'sunos': ['solaris', 'posix', 'generic']
                  }

try:
    env['PLATCHAIN'] = PLATFORM_CHAIN[env['PLATFORM']]
except KeyError:
    raise StopError('Unsupported platform "%s"' % env['PLATFORM'])

if env['PLATFORM'] == 'win32':
    env.Macroses('_WINSOCKAPI_')

# Create definitions like PLAT_SOLARIS
env.Macroses(*('PLAT_' + plat.upper() for plat in env['PLATCHAIN']))

env.Append(LIBPATH = env.Target('lib'))   

env['PLATDEBUG'] = True
env['PLATCACHE'] = 'plat_cache.pch'
#
PlatIncBuilder = Builder(action = '%s tools/plat/parse-include.py $SOURCES' % (sys.executable),
                         src_suffix = '.h')
PlatSrcBuilder = Builder(action = '%s tools/plat/proc-source.py $SOURCE > $TARGET' % (sys.executable),
                         suffix = '.c',
                         src_suffix = '.c')
env.Append(BUILDERS = {'PlatIncBuilder': PlatIncBuilder, 
                       'PlatSrcBuilder': PlatSrcBuilder})

if env['PLATFORM'] == 'sunos':
    env['CTFCONVERT'] = '/opt/onbld/bin/i386/ctfconvert'
    env['CTFMERGE'] = '/opt/onbld/bin/i386/ctfmerge'
else:
    env['CTFCONVERT'] = None
    env['CTFMERGE'] = None

# Building shared libraries
SConscript('lib/libjson/SConscript', 'env', 
           variant_dir = env.BuildDir('libjson'))
SConscript('lib/libtscommon/SConscript', 'env', 
           variant_dir = env.BuildDir('libtscommon'))
SConscript('lib/libhostinfo/SConscript', 'env', 
           variant_dir = env.BuildDir('libhostinfo'))
SConscript('lib/libtsagent/SConscript', 'env', 
           variant_dir = env.BuildDir('libtsagent'))
SConscript('lib/libtsload/SConscript', 'env', 
           variant_dir = env.BuildDir('libtsload'))

# Building commands

SConscript('cmd/tsloadd/SConscript', 'env', 
           variant_dir = env.BuildDir('cmd_tsloadd'))
SConscript('cmd/run-tsload/SConscript', 'env', 
           variant_dir = env.BuildDir('cmd_run_tsload'))

# Building modules

for mod in Dir('mod').glob('*'):
    mod_name = os.path.basename(str(mod))
        
    SConscript(PathJoin(str(mod), 'SConscript'), 'env', 
           variant_dir = env.BuildDir('mod_' + mod_name))

SConscript('test/mempool/SConscript', 'env', 
           variant_dir = env.BuildDir('cmd_mpbench'))