import os
import sys

from SCons.Errors import BuildError 

PathJoin = os.path.join
PathBaseName = os.path.basename
PathExists = os.path.exists

def BuildDir(self, dir):
    return PathJoin('#build', 'build', dir)

def Target(self, target):
    self['CURTARGET'] = target
    
    return PathJoin('#build', self['PLATFORM'], target)

def AddDeps(self, *deps):
    for dir, dep in deps:
        inc_dir = PathJoin(dep, 'include')
        
        self['CPPPATH'] += [self.BuildDir(inc_dir)]
        self['LIBS'] += [dep]

def Module(self, mod_name):
    mod = self.Clone(CFLAGS = ['-DNO_JSON'])
    
    mod.AddDeps(('lib', 'libtscommon'), ('lib', 'libtsload'))
    mod.SharedLibrary(mod.Target(PathJoin('mod', mod_name)), Glob("src/*.c"))

def InstallFile(self, target, file_name):
    self.Command(PathJoin(self.Target(target), file_name),
                 file_name, Copy("$TARGET", "$SOURCE"))

def PreparePlatform(self):
    self.Append(ENV = {'PLATCACHE': PathJoin(Dir('.').path, self['PLATCACHE'])})
    self.Append(ENV = {'PLATDEBUG': self['PLATDEBUG']})
    
    plat_chain = list(reversed(self['PLATCHAIN']))
    plat_cache = self['PLATCACHE']
    
    plat_includes = []
    
    self.PlatIncBuilder(plat_cache, Dir('include').glob('*.h'))
    
    # Build platform-chained includes and sources
    for plat_name in plat_chain:      
        # For each platform-dependent include select best match and copy
        # it from plat/<platform>/include.h to plat/include.h
        for inc_file in Dir('include').Dir('plat').Dir(plat_name).glob('*.h'): 
            base_name = PathBaseName(str(inc_file))
            dest_file = PathJoin('include/plat', base_name)
            
            if base_name not in plat_includes:
                self.Command(dest_file, inc_file, Copy("$TARGET", "$SOURCE"))
                
                plat_includes.append(base_name)
        
        # Parse source files for platform-api function implementation
        # and select best match for it
        for src_file in Dir('src').Dir('plat').Dir(plat_name).glob('*.c'):            
            tgt_file = File(str(src_file).replace('src/plat', 'plat'))            
            
            # Each source file depends on platform cache
            # and all source that are more specific than this file
            # Otherwise SCons will select generic implementation
            base_name = PathBaseName(str(src_file))
            
            self.Depends(tgt_file, plat_cache)
            
            # Add dependencies for all available platforms to ensure that
            # most specific platform will be built earlier than "generic" platfrom
            for dep_plat_name in plat_chain[plat_chain.index(plat_name) + 1:]:
                dep_plat_path = PathJoin('plat', dep_plat_name, base_name)
                
                if not PathExists(dep_plat_path):
                    continue
                
                self.Depends(tgt_file, dep_plat_path)
            
            # Add builder 
            self.PlatSrcBuilder(tgt_file, src_file)

# Prepare build environment

env = DefaultEnvironment()

env.AddMethod(AddDeps)
env.AddMethod(BuildDir)
env.AddMethod(Target)
env.AddMethod(Module)
env.AddMethod(InstallFile)
env.AddMethod(PreparePlatform)

env['DEPTARGETS'] = {}
env['CURTARGET'] = ''

env['CPPPATH'] = ['#include', 'include']
env['LIBPATH'] = [env.Target('lib')]
env['LIBS'] = []

env['CCFLAGS'] = ['-m64', '-Wall']

# env[] syntax not working here :(
env.Append(LINKFLAGS = ['-z origin'])
env.Append(RPATH = env.Literal(os.path.join('\\$$ORIGIN', os.pardir, 'lib')))

# For debugging
env['CCFLAGS'] += ["-g"]
env['CCFLAGS'] += ["-DTS_LOCK_DEBUG"]

env['CCFLAGS'] += ['-DJSON_DEBUG', '-DJSON_MEMORY_CALLBACKS', '-DJSON_INT_TYPE=long long']

# Supress "unused" warnings
env['CCFLAGS'] += ['-Wno-unused-label', '-Wno-unused-variable', '-Wno-unused-function']

# Cross-platform build
env['PLATCHAIN'] = ['linux', 'posix', 'generic']
env['PLATDEBUG'] = True
env['PLATCACHE'] = 'plat_cache.pch'

#
PlatIncBuilder = Builder(action = '%s tools/plat/parse-include.py $SOURCES' % (sys.executable),
                         src_suffix = '.h')
PlatSrcBuilder = Builder(action = '%s tools/plat/proc-source.py $SOURCE > $TARGET' % (sys.executable),
                         suffix = '.c',
                         src_suffix = '.c')
env.Append(BUILDERS = {'PlatIncBuilder': PlatIncBuilder, 
                       'PlatSrcBuilder': PlatSrcBuilder})

# Building shared libraries
SConscript('lib/libjson/SConscript', 'env', 
           variant_dir = env.BuildDir('libjson'))
SConscript('lib/libtscommon/SConscript', 'env', 
           variant_dir = env.BuildDir('libtscommon'))
SConscript('lib/libhostinfo/SConscript', 'env', 
           variant_dir = env.BuildDir('libhostinfo'))
SConscript('lib/libtsagent/SConscript', 'env', 
           variant_dir = env.BuildDir('libtsagent'))
SConscript('lib/libtsload/SConscript', 'env', 
           variant_dir = env.BuildDir('libtsload'))

# Building commands

SConscript('cmd/tsloadd/SConscript', 'env', 
           variant_dir = env.BuildDir('cmd_tsloadd'))

# Building modules

for mod in Dir('mod').glob('*'):
    mod_name = os.path.basename(str(mod))
        
    SConscript(PathJoin(str(mod), 'SConscript'), 'env', 
           variant_dir = env.BuildDir('mod_' + mod_name))